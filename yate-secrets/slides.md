yate secrets
============

Разные странные, неочевидные или просто недокументированные особенности.

Массивы
-------

  * Массивы воспринимаются примерно так:

        {
            "foo": [ 1, 2, 3 ]
        }

    как бы представляется в виде объекта:

        {
            "foo": 1,
            "foo": 2,
            "foo": 3
        }

  * На вход шаблонизатора всегда подается `Object`.
    С недавних пор можно использовать `Array`, который будет автоматически
    обернут в объект вида:

        {
            "item": array
        }

  * Вложенные массивы лучше не использовать. Поведение непредсказуемо:

        [
            [ 1, 2, 3 ],
            [ 4, 5, 6 ],
            [ 7, 8, 9 ]
        ]

    Проблема в том, что у каждой "ноды" должно быть имя.
    Если массив не является значением объекта, то этого имени нет ---
    "анонимный" массив. Предполагается в будущем трактовать их как ноды
    с предопределенным именем. Например, `item` (или `token`).


Типизация
---------

  * Типизация --- статическая. Т.е. типы всех выражений, переменных, параметров и т.д. определяются
    на стадии компиляции.

  * Типы бывают вот такие:

      * Базовые: `scalar`, `boolean`, `nodeset`, `xml`, `attr`.
      * Еще: `object`, `array`.
      * Внутренние: `pair`, `attrvalue`, ...

  * Нет различий между числом и строкой. Это все `scalar`.

  * Разница между `+` и конкатенацией.
    Плюс --- всегда арифметический. Для конкатенации нужно использовать такие варианты:

        .foo + .bar // неправильно!

        "{ .foo }{ .bar }"

        .foo
        .bar

  * `scalar` и `xml` --- это в общем-то строки. Разница только в том, что `scalar` при выводе эскейпится.

  * `nodeset` --- это массив нод. Тип `node` отдельно не существует. Одна нода ---
    это все равно массив из одного элемента.
    Внутри нода это некий объект, примерно такого вида:

        {
            data: { ... },
            name: "foo",
            parent: ..., // ссылка на родительскую ноду или null
            doc: ... // раньше там было поле root.
        }

    В будущем этот объект точно изменится. Так что лучше во внешних функциях до уровня нод не лезть.

  * `attr` --- это один или несколько html-атрибутов. Функция (в том числе и внешняя) или шаблон
    могут вернуть результат с таким типом:

        func attrs() {
            @class = "hello"
            @id = "my-id"
        }

    Внутреннее представления опять таки может поменяться в будущем.

  * Вообще говоря, почти все является выражением (блочным или инлайновым) и имеет тип.
    Например,

        foo = if .foo {
            .foo
        } else {
            .bar
        }

    У `foo` тип `nodeset`.

    У `for` тип может быть `scalar`, `xml`, `attr`.

    У `if` --- `scalar`, `xml`, `attr`, `nodeset`, `boolean`.
    Тип блоков `then` и `else` должны быть совместимы --- т.е. приводиться к одному типу.
    Если `else` осутствует, то есть дефолтное значение (`false` для `boolean`, `""` для `scalar` и `xml`, пустой `nodeset`).

Приведение типов
----------------

  * В большинстве случаев выражения приводятся к нужному типу автоматически.

        func foo(scalar s) {
            ...
        }

        foo(.foo) // nodeset -> scalar

  * Но иногда нет.

        match .foo (scalar s) {
            ...
        }

        apply .foo (.boo)
        apply .foo ("hello")

    Т.е. при вызове шаблона можно передать аргументы разных типов
    и статически нельзя определить, что же конкретно придет в шаблон.
    Это можно понять только в рантайме.
    Но я пока стараюсь в рантайме ничего специально не проверять по-возможности.

    Правильный вариант вызова:

        apply .foo( scalar(.boo) )
        apply .foo( "hello" ) // тут тип уже scalar.

  * Функции для приведения: `boolean()`, `scalar()`, `html()` (с названиями беда).


Матчинг
-------

  * Разница между предикатом, индексом и гвардом.

  * Неочевидный пример:

        is-foo = .foo

        match /[ is-foo ] {
            ...
        }


Производительность
------------------

  * Вызов шаблона с параметрами дороже, чем без (из-за `.apply()`).

  * Нодесеты сравниваются "каждый с каждым". Пример:

        if .foo == "a" || .foo == "b" || .foo == "c" {
            ...
        }

    Если в `.foo` --- скаляр, то лучше так:

        foo = scalar(.foo)

        if foo == "a" || foo == "b" || foo == "c" {
            ...
        }


Ключи
-----

Импорты и инклюды
-----------------

  * Инклюды раскрываются по месту использования.

`|` vs `||`
-----------

    title = img.title || img.fileName

